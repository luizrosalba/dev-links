# Typescript

## Intro 

TypeScript is a strongly typed programming language that builds on JavaScript, giving you better tooling at any scale.

## Playground 

[https://www.typescriptlang.org/play?#code/Q](https://www.typescriptlang.org/play?#code/Q)

## Type x Interface

Type aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.

![Types vs Interfaces](https://previews.dropbox.com/p/thumb/ABwXznEvfkInvleim8Yvgn_C3WWhCrRFV5-eTjl7Zg7bRqVDpLgVIfAOAXDt3qPsrcWVlRzmEdpy9eQccl3msut2QrvYQX2K14XFctlJ9MAdD1yI8ebZweF0iFWSXm14UkqTjiYP7oDH5JS-CvSbGS2i52PeWTLvleok6QwGjR6vZmTLaJ6wC2CMeHTk0cYeEJF-I1M1KGfJ38pubLNygsNjiaVMhtzwGZ5kEP08HC-0VZFUaytdr9bSLemfacxGt_7WPsno_pRo2Dj6Rmk71wYbA5nPENEvGsf9oNixw8IdKku06KzjXSyhUNB2nLLrzgJI-QcwgMUcgmDHBrGgscT1PThynDfKdv6BVYXnFu1CBfoect6qkZLDa1enolKh6oE/p.png)

[https://www.typescriptlang.org/play#example/types-vs-interfaces](https://www.typescriptlang.org/play#example/types-vs-interfaces)

[Stack Overflow](https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript/52682220#52682220)

[Differences](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)

## CheatSheets

[https://www.sitepen.com/blog/typescript-cheat-sheet](https://www.sitepen.com/blog/typescript-cheat-sheet)

![1](https://previews.dropbox.com/p/thumb/ABx5LCDPpl9IdyW0Y1_YEIg1MwYR_8NxPZuycxHBNFzCBRXznCU8tvt3jxs4e3O0lg52eAxO8rMI76X2R5FhHL83pWPQzWScIrd8jW-vuO8bfffISxmPDbrCijtwsqyY0TLc-qApiVZoD-9Cbu1yT6Uy88428TCzjDyIqZtNW9IcJsBBs1P6Bqg-AaWMu-yUzvTlkoRX_h7ww15ynDRY6B-F237iqgekIUlqiKJy6MU_uhBrJFmXwuVoSVMXdUx36MQR_zoLFHYKxajdK8a4ldLpT-Cv1IxxqSs8Z6-DFibB-pBRpJn-grSlvESF2KhD8JNTtAAF3zKRmJhymdBlz9LYzCnxMcRWgdlZ1sUDWfVG5Uz9IqzS7kYO1a_iQ-Z-C0c/p.png)

![2](https://previews.dropbox.com/p/thumb/ABwZM67keVUzIiN3YLuLdX-FBWYgC2CX5S95cVWRUKfGNk1KsaTzMuXR-y39ZlJcK2I2F76n-4dmE5fKJ5x7S37CmOWWLnGfNyHkXc9hPoA0GRwv7lOes0PAGejVp_G_6Ytyh17ZqFtSHVdZOvoEKU_CMu7Q2VXg-3GNdYQblrK48brA60S79Fy0Mfs13x362VVHqnvEgDBIOw4fbq5krPdlO-GTxyCTcIj0c8hy2snNWGd3SN8qGU1zJcCu55xVMxu4hN5tBtCrPckI8F01nJVvoEiaGHN9oxG-fe_aTMHmJ8OTjfjO_t20cxhSz1a3J4lXMf_HIuzjsZSOEaFROYc6uHJfPnAXLfFOUyP2kwWC1yFuOzUzZJ1HtiqFqhASSbw/p.png)

![3](https://previews.dropbox.com/p/thumb/ABz6VklZgjz-w3mPfoCLl4-OBUe1YF1dAk8OegX_48yQxSwpkC0-chOX5pTwFXvRyoghnz02EeCkrctw7BnCMUNkWKhRnvI6UwKI7lBgccB7yVWPHwJoW-gXOKwm_TfITTGxVMJX_44J5PrgE7AOX6i9T_40sog1nmL6OUDKyBYCdaB2oU6I9evlIbNJxekp_clzSEjqmnZ0LiyqscnFfLH-y5sT44w_GGBFPXEzPPfFhAZu1qBviUChtfVoze3c4q1z8UVkZQN4W3btb5abWwF2WkNfClJi84Eajni3bKNNeTu2hsJrVIZhiAxcfwoLymuRc-d3cNJ_jhHQD5s7vonANhAe49ou5T3Vh1W5iDBpVde1-BwPIz1DaiLs5gClfe8/p.png)

![4](https://previews.dropbox.com/p/thumb/ABx6uofqkw7EVbv4bxJZkZ4UdSITAWUzrLofrVvQtp9ttuH-OMwhp6cR5noruwAtYzLR_7KCbU9iqMEfHeYaepSbzWjznuNdd1A2Uns_4KOvbZSa7iUPQ9tCO2VjVx_zNXtwOgSaAdOAXU-xy-4Yqb_Mko2gGaWcM4hLaMyI8QYkONYptrNFql6J8aOR2zMe61g59okJk5pJIkJBWq68JvDv8PULFASkuE4AxS2DS8STKCWumVmPMwcYoVaJ-vOjk9wrdjHZFKN1OidlBg6b6MeCgw3PuDT78x-kV0K5XoiY-P6mFJjb3Y2W8SgWsmHsf5MRA511DfCFahtYH5GbglTPIrOTM6pAu8EQldD73iu-7ZyV5nZ-Z1uW9htssf3KoCw/p.png)


## Good Practices 

1) Use unknown instead any 

Unknown can be used to define a variable type latter on the code

2) Use Type Guard 

```typescript
interface IUser {
    id: number
    firstName: string 
    lastName: string
    gender: string
    image: string
    age: number
}

interface IAdminUser extends IUser {
    token : string 
    addNewUser: () => void
}

// object is IAdminUser is type guard
function isAdminUser(object: unknown): object is IAdminUser {
    if (object !== null && typeof object === "object")
        return "token" in object /// check if token inside object
    return false
}

// object is IAdminUser is type guard
function isRegularUser(object: unknown): object is IUser {
    if (object !== null && typeof object === "object")
        return "token" in object /// check if token inside object
    return false
}

async function fetchUser() {
    const response = await fetch('https://dummyjson.com/users/1')
    // Bad No checking if admin or not even if we use badUser: IAdminUser interface no checking is done 
    const badUser = await response.json();
    // Good using Type Guard
    const goodUser: unknown = await response.json();
    if (isAdminUser(goodUser){
        ///goodUser will have all IAdminUser methods
        
    })
    if (isRegularUser(goodUser){
        ///goodUser will have all IUser methods
        
    })
}
```

3) Use is operator

```typescript
type Species = "cat" | "dog"; 
interface Pet { 
    species: Species
}
class Cat implements Pet {
    public species: Species = "cat" 
    public meow(): void {
        console.log("meow")
    }
    public jump(): void {
        console.log("jumping")
    }
    public walk(): void {
        console.log("walking")
    }
    /// Good Is operator
    function petIsCat(pet: Pet): pet is Cat{
        return pet.species === "cat";
    }
    /// Bad wont enable TS to know return is Cat, no autocomplete
    function petIsCatBoolean(pet: Pet): boolean{
        return pet.species === "cat";
    }
}
const p: Pet = new Cat(); 

/// bad 
/// p.meow() does note exists on type Pet 

if (petIsCatBoolean(p)) {
    (p as Cat).meow(); /// bad , will have to repeat the type casting for every method 
}

if (petIsCat(p)) {
    p.meow(); /// good, will use is Operator 
}
```
4) Use satisfies operator (added on TS 4.9)

```typescript
interface ICustomImage {
    data: string
    width: number
    heigth: number

}
const myCustomImage: ICustomImage = {
    data: "base64",
    width: 200,
    height: 150,
}

type UserImage = string | ICustomImage 

interface IUser {
    id: number
    firstName: string 
    lastName: string
    image: UserImage
}

/// Bad 
const badUser: IUser = { 
    id: 1,
    firstName:'Alex',
    lastName: 'Brooks',
    image: 'image-url',
} 
/// badUser.image. wont have all string methods. TS dont know if string or ICustomImage and will make an intersection between these two types 
/// Good 
const goodUser: IUser = { 
    id: 1,
    firstName:'Alex',
    lastName: 'Brooks',
    image: 'image-url',
} satisfies IUser

```

5) Use enums correctly

```typescript 
enum BadState { 
    InProgress,
    Success, 
    Fail
}

const badCheckState = (state: BadState ) => {

}

/// would not raise error 
badCheckState(100);

/// Good 

type GoodState = "InProgress" | "Success" | "Fail" 

/// also good 
enum GoodState2 {
    InProgress = "InProgress"
    Success = "Success"
    Fail = "Fail"
}

const goodCheckState = (state: GoodState ) => {

}

goodCheckState("dfnsndf") // will fail 

```
6) Use Utility Types 

Suppose we wanted to update a single field of a product. We could make all files of IProduct optional 


```typescript 
interface IProduct {
    id: number
    title: string 
    description: string
    thumbnail: string
    price: number
    rating: number
}

/// Partial make anything inside that interface Optional
/// Omit remove id from IProduct
function updateProduct (
    productID: IProduct["id"].
    updateProduct: Partial<Omit<IProduct, "id">>
){
    updateProduct. // wont show id
}


```
7) Use Record 

```typescript
type Properties = "red" | "green" | "blue"
type RGB = [red: number, green: number, blue: number]

// Record create keys and values 
// keys only can be Properties and values can be RGB or String 
const color: Record<Properties, RGB | string > = {
    red: [255,0,0]
    green: "green" 
    blue: "blue"
}
```

## References 

[https://www.typescriptlang.org/docs/handbook/intro.html](https://www.typescriptlang.org/docs/handbook/intro.html)

[https://www.typescriptlang.org/](https://www.typescriptlang.org/)

[Mistakes to Avoid](https://www.youtube.com/watch?v=ZCllX1p763U)