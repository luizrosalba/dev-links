# OAuth

[https://www.udemy.com/course/oauth-2-simplified/](https://www.udemy.com/course/oauth-2-simplified/)

## 1.2 A Brief History of OAuth

- In OAuth, we focus on OAuth from the perspective of building OAuth applications and accessing APIs. And then secondly, we talk about the other side, which is protecting APIs with OAuth.
- how to use OpenID Connect to learn information about the user.
- validate Access Tokens and how to deal with revoked access

## 1.3 How OAuth Improves Application Security

- Before OAuth it was actually very common for API is to use HTTP Basic Auth. That's just an application sending a username and password to the API.
- Applications had to ask the user for their password, store that password and then use that password in API requests.
- When third party apps, like using third party Twitter clients want to dot his, they would have to ask the user for their password and then store it and use it at.
- Applications needed to access user data from third party apps without the users sharing their password.
- What OAuth does at a high level is requires that every application sends the user out to the OAuth server to log in there, and then redirects them back to the app so the app can get tokens.
- The key thing here is this redirect step. It means the user actually leaves the application and they go type in their password at the OAuth server instead of ever giving their password to the application.
- If you wanted to add MFA, you don't need to make any changes to the apps at all, since you just turn it on at your OAuth server and it would immediately be enabled across all of your applications.

## 1.4 OAuth and OpenID

- OAuth was originally designed for applications to get access to APIs.
- The application doesn't actually need to know who the user is that's using that application.

- So when you go to a hotel and you check in, you show the person at the front desk your ID and your credit card, and they give you back a hotel key. Now, this key card is what you use to go access rooms in the hotel. So you might take it to the door of your room, swipe it on the door and the door opens up and lets you in. Now, in order for that system to work, the door doesn't actually need to know who you are, right? The person at the front desk knows who you are. They're the ones that checked your ID, but they give you back this key card which represents access to that room. You might then also take that keycard and access the hotel gym or the pool or other resources in the hotel. And this is exactly analogous to OAuth, where the person at the front desk is like the OAuth authorization server. They're the one checking ID cards and authenticating the user. On the other hand, if the application does need to know who the user is, for example, if it wants to show their name in the interface or show their profile photo in the corner, that's where we need something besides OAuth, because OAuth doesn't actually give us that information. There's nothing in OAuth that communicates user information, that's all added externally. Now, the main way that's added is using OpenID Connect.

- Just like a hotel key, the application using the access token doesn’t need to know anything about how it works.

- Applications should just use the access token in an API request and let the API figure out if it’s valid.
- OpenID Connect takes OAuth as a foundation and it adds in user identity information on top.
- OAuth issues access tokens to apps, OpenID Connect issues ID tokens to apps and the ID Token is a statement about the user.
- OAuth is always about accessing APIs and OpenID Connect is about identifying the user. Think about accessing APIs and identifying users.

## 2.5 Application Types

- In this lesson, we're going to introduce the role of the authorization server and show how OAuth exchange works and solves some of these problems.
- In a typical scenario of a user trying to access some data in an API, we have four roles.

- First, the user, they are the person with the account.
- Secondly, there's the device. They are using this device like their mobile phone or their browser.And that device is either running an application or accessing an application.
- The application is the third role. So if it's a mobile phone, for example, the app is running on the device and if it's a browser, then the device is accessing the application over the internet.
- The fourth role is the API, and that is the thing the application is making requests to.

- In the OAuth spec, you'll see these more specific terms.
- Instead of the user, the spec calls it the Resource Owner.
- Instead of device it's actually the User Agent.
- Instead of the application, it's called the OAuth Client.
- Instead of the API, it's called the Resource Server.

## 2.6 Application Types

OAuth 2.0 defines two client types, confidential clients and public clients. These are based on whether the client has credentials that it can use as authentication during the OAuth flow. The difference between these two types of applications is whether the application has some sort of credentials. Confidential clients have credentials, typically a client secret, and public clients don't.If you're writing a mobile app or a single page app, then you don't have the ability to include secrets into the app because users of the app would be able to see the secrets.It's most obvious in the case of single-page apps, since users of the app can always click on the view source button in the browser and then just start poking around thesource code. There's no way to ship a secret in the source code and have it remain secret.It's a little bit less obvious, but it's also true for mobile apps.While there's no view source button, there are still plenty of tools available for people to extract strings out of the binary files. Essentially, the difference is any time the application will be running on a device that the user controls, you can't include a secret in that application.And this is true of any kind of application running on a user's device, including things like an Apple TV or even Internet of Things devices.All right. So we know how to determine what kind of app something is, but what does this have to do with OAuth?

In OAuth, the application will be communicating with the authorization server, and if the application has credentials, then the application can use those credentials to authenticate the requests it makes.That means the server will know that only the real application can make requests if it includes the application's credentials. Without credentials, the authorization server never really knows if it's the real application making requests or something pretending to be the real application. The reason this distinction matters is that the authorization server might have policies that make it act differently depending on the type of client making the request. For example, a confidential client that is also a first party client might skip the consent screen. And that's because the authorization server can be sure that only the real application could end up with the access token after the flow is complete.However, for a first party public client, an attacker could mimic the real application by copying its client ID and starting a flow. And if they can control the redirect URL, they could then end up with the access tokens that the authorization server thought were issue to the real application. Some of the other things the authorization server might do differently depending on the client is whether to include refresh tokens or changing the token lifetimes to mitigate risk. All these things are reasons to use client authentication whenever possible.By far, the most common type of credential used with confidential clients is a client secret. This is basically the same as an API key or a password. It is a string of characters that is shared between the server and the client. This is the most common because it is the easiest to use, but it is not the most secure.A more secure form of client authentication involves using a public/private key pair in some form.There are a few different standard options for this, including Mutual TLS and using a private key to sign a JWT. We won't go into the details of these other methods in this course since they are far less common and are really used only when you need a higher level of security.If you are interested in learning more about these alternative forms of client authentication, you can visit https://oauth.net/2/client-authentication/ to find links to
additional resources. So in summary, confidential clients are apps running on a server that can be deployed with a client secret or other credentials. Public clients can't be deployed with credentials, so the authorization server can't be sure that requests made from public clients are genuine or being made from someone mimicking the application. In any case, as a client developer, the best you can do is make sure you choose the appropriate type when you're registering the application at the OAuth server and always make sure to safeguard your client credentials if you have them. And remember, never put a client secret into a mobile application or a single page application because then it wouldn't be secret anymore.

## 2.67 User Consent

One of the goals of OAuth is to protect a user's data and ensure it's shared with only parties that the user wants to share it with.If you think back the last time you clicked a Sign In with Twitter button, you might remember that you saw a screen like this asking if you are sure you want to share your information. This screen that interrupts the authorization flow is known as the consent screen because it's asking the user for permission. In this lesson, we'll look at how the screen is critical to the flow so that the authorization server knows it's doing its job and protecting the user in order to better understand why this step is useful. Let's first look at what happens if we don't have this screen in the flow. If you read through the OAuth spec, you'll see references to the password grant, also known as the resource owner password flow. The way that flow works is the application presents a password prompt in the app itself,collects the user's password and then sends it to the authorization server and gets back an access token. The request itself is so simple it's barely worth mentioning. It's just one POST request.  The token endpoint that contains the username and password along with the client and optionally the client secret.
Let's take a step back and think about this for a minute. The user hands over their password to the client and the client goes and takes it to the authorization server to get an access token. If you remember back in the first section of this course, we saw examples of third party apps asking you to enter your Gmail password. It's clearly a problem if a third party app were to use the password grant because the user is handing their password over to an app under another developer's control. This has always been a problem and the spec has always advised against allowing third party apps to use the password grant. What's more subtle, though, are the problems that even first party apps have when using the password grant. So let's think about this from the point of view of the authorization server. As the authorization server, your job is to protect the resources, ensuring only applications and users that are authorized get access.
If you get a password grant request, all you see is that the application is presenting the user's credentials. You don't actually have any way to know if the user themselves are actually trying to log in. You don't know if the user is using this app right now or if the app has stored the user's password from the last time they logged in. And that's because this request looks the same, whether or not the user is actually actively using the application. So even if you do trust the app not to store and replay the user's password, you also can't be sure that the user actually agrees to whatever access the app is requesting. It might be telling the user it's going to only read their photos, but because it has their password, it can actually request a token that could modify their photos too. The thing missing from this is actually confirming that the user is actually at the computer and has initiated and agrees to this request right now.
So this is really where the role of the authorization server solves this. By inserting the authorization server into the flow. The application actually first directs the user to the authorization server. The user types in their password there, approves the request after they see the consent screen, and then they get taken back to the app. This way, the user is only ever typing their password into the authorization server. And then the authorization server knows that the user is actually attempting to use that application. It prevents the application from being able to do anything without the user actually being in front of the keyboard. It also means the application can ask for certain kinds of access and the authorization server can show that request to the user. And that way the authorization server knows the user is actually agreeing to it. And that's this consent step here where the user is shown a prompt asking if they would like to share their data with the application. There's another huge problem with the password grant which is solved by using a redirect flow. In recent years, we've seen an explosion in the use of multifactor authentication, which is a huge step up for security. The problem with the password grant is there's really no room to add multifactor into the flow. The grant is just exchanging the password for an access token, and it wasn't designed to add multifactor into the flow.
If you did want to extend the password grant to support multifactor, you're going to have to just do it on your own and make it up and build it into each one of your applications from scratch. So instead, by redirecting the user to the authorization server, you can add a new multifactor method at any time by adding it to your authorization server. And then suddenly every application using that server will immediately support it without changing any of the code in the applications. This has a huge impact if you're responsible for deploying dozens or hundreds of apps, especially across different teams, since it means you no longer need to coordinate the efforts to change or add support for a new multifactor authentication methods, you could just turn them on with the authorization server whenever you want. The last thing I want to say about user consent is that typically the step of actually interrupting and asking the user for permission is skipped for first party confidential clients. The idea is that if you're logging into the web application of your own service where a user has an account, you don't really need to ask their permission to log in, since it's a first party scenario. And if it's a confidential client, then there's really no app impersonation risk either. So it's safe to skip the consent feature and redirect back immediately. That said, that redirect step is still key here as that's how you're able to get all the security benefits and better add multifactor authentication. But you can have the user automatically redirected back without a consent prompt if you wish. If you're on a mobile or single page app and if you are worried that someone might try to trick users into logging to a fake app, impersonating your own apps, then you might still want to turn on the consent feature for your own first party apps just so that you can make it harder for attackers to trick your users into authorizing a fake application. So in summary, using a redirect based method is a much safer and much more flexible alternative to the password grant and allows you to easily add multifactor authentication in the future and provides assurance that the user is really in front of the computer when logging into applications. 

