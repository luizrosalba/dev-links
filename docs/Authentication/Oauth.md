# OAuth

[https://www.udemy.com/course/oauth-2-simplified/](https://www.udemy.com/course/oauth-2-simplified/)

## 1.2 A Brief History of OAuth

- In OAuth, we focus on OAuth from the perspective of building OAuth applications and accessing APIs. And then secondly, we talk about the other side, which is protecting APIs with OAuth.
- how to use OpenID Connect to learn information about the user.
- validate Access Tokens and how to deal with revoked access

## 1.3 How OAuth Improves Application Security

- Before OAuth it was actually very common for API is to use HTTP Basic Auth. That's just an application sending a username and password to the API.
- Applications had to ask the user for their password, store that password and then use that password in API requests.
- When third party apps, like using third party Twitter clients want to dot his, they would have to ask the user for their password and then store it and use it at.
- Applications needed to access user data from third party apps without the users sharing their password.
- What OAuth does at a high level is requires that every application sends the user out to the OAuth server to log in there, and then redirects them back to the app so the app can get tokens.
- The key thing here is this redirect step. It means the user actually leaves the application and they go type in their password at the OAuth server instead of ever giving their password to the application.
- If you wanted to add MFA, you don't need to make any changes to the apps at all, since you just turn it on at your OAuth server and it would immediately be enabled across all of your applications.

## 1.4 OAuth and OpenID

- OAuth was originally designed for applications to get access to APIs.
- The application doesn't actually need to know who the user is that's using that application.

- So when you go to a hotel and you check in, you show the person at the front desk your ID and your credit card, and they give you back a hotel key. Now, this key card is what you use to go access rooms in the hotel. So you might take it to the door of your room, swipe it on the door and the door opens up and lets you in. Now, in order for that system to work, the door doesn't actually need to know who you are, right? The person at the front desk knows who you are. They're the ones that checked your ID, but they give you back this key card which represents access to that room. You might then also take that keycard and access the hotel gym or the pool or other resources in the hotel. And this is exactly analogous to OAuth, where the person at the front desk is like the OAuth authorization server. They're the one checking ID cards and authenticating the user. On the other hand, if the application does need to know who the user is, for example, if it wants to show their name in the interface or show their profile photo in the corner, that's where we need something besides OAuth, because OAuth doesn't actually give us that information. There's nothing in OAuth that communicates user information, that's all added externally. Now, the main way that's added is using OpenID Connect.

- Just like a hotel key, the application using the access token doesn’t need to know anything about how it works.

- Applications should just use the access token in an API request and let the API figure out if it’s valid.
- OpenID Connect takes OAuth as a foundation and it adds in user identity information on top.
- OAuth issues access tokens to apps, OpenID Connect issues ID tokens to apps and the ID Token is a statement about the user.
- OAuth is always about accessing APIs and OpenID Connect is about identifying the user. Think about accessing APIs and identifying users.

## 2.5 Application Types

- In this lesson, we're going to introduce the role of the authorization server and show how OAuth exchange works and solves some of these problems.
- In a typical scenario of a user trying to access some data in an API, we have four roles.

- First, the user, they are the person with the account.
- Secondly, there's the device. They are using this device like their mobile phone or their browser.And that device is either running an application or accessing an application.
- The application is the third role. So if it's a mobile phone, for example, the app is running on the device and if it's a browser, then the device is accessing the application over the internet.
- The fourth role is the API, and that is the thing the application is making requests to.

- In the OAuth spec, you'll see these more specific terms.
- Instead of the user, the spec calls it the Resource Owner.
- Instead of device it's actually the User Agent.
- Instead of the application, it's called the OAuth Client.
- Instead of the API, it's called the Resource Server.

## 2.6 Application Types

OAuth 2.0 defines two client types, confidential clients and public clients. These are based on whether the client has credentials that it can use as authentication during the OAuth flow. The difference between these two types of applications is whether the application has some sort of credentials. Confidential clients have credentials, typically a client secret, and public clients don't.If you're writing a mobile app or a single page app, then you don't have the ability to include secrets into the app because users of the app would be able to see the secrets.It's most obvious in the case of single-page apps, since users of the app can always click on the view source button in the browser and then just start poking around thesource code. There's no way to ship a secret in the source code and have it remain secret.It's a little bit less obvious, but it's also true for mobile apps.While there's no view source button, there are still plenty of tools available for people to extract strings out of the binary files. Essentially, the difference is any time the application will be running on a device that the user controls, you can't include a secret in that application.And this is true of any kind of application running on a user's device, including things like an Apple TV or even Internet of Things devices.All right. So we know how to determine what kind of app something is, but what does this have to do with OAuth?

In OAuth, the application will be communicating with the authorization server, and if the application has credentials, then the application can use those credentials to authenticate the requests it makes.That means the server will know that only the real application can make requests if it includes the application's credentials. Without credentials, the authorization server never really knows if it's the real application making requests or something pretending to be the real application. The reason this distinction matters is that the authorization server might have policies that make it act differently depending on the type of client making the request. For example, a confidential client that is also a first party client might skip the consent screen. And that's because the authorization server can be sure that only the real application could end up with the access token after the flow is complete.However, for a first party public client, an attacker could mimic the real application by copying its client ID and starting a flow. And if they can control the redirect URL, they could then end up with the access tokens that the authorization server thought were issue to the real application. Some of the other things the authorization server might do differently depending on the client is whether to include refresh tokens or changing the token lifetimes to mitigate risk. All these things are reasons to use client authentication whenever possible.By far, the most common type of credential used with confidential clients is a client secret. This is basically the same as an API key or a password. It is a string of characters that is shared between the server and the client. This is the most common because it is the easiest to use, but it is not the most secure.A more secure form of client authentication involves using a public/private key pair in some form.There are a few different standard options for this, including Mutual TLS and using a private key to sign a JWT. We won't go into the details of these other methods in this course since they are far less common and are really used only when you need a higher level of security.If you are interested in learning more about these alternative forms of client authentication, you can visit https://oauth.net/2/client-authentication/ to find links to
additional resources. So in summary, confidential clients are apps running on a server that can be deployed with a client secret or other credentials. Public clients can't be deployed with credentials, so the authorization server can't be sure that requests made from public clients are genuine or being made from someone mimicking the application. In any case, as a client developer, the best you can do is make sure you choose the appropriate type when you're registering the application at the OAuth server and always make sure to safeguard your client credentials if you have them. And remember, never put a client secret into a mobile application or a single page application because then it wouldn't be secret anymore.

## 2.7 User Consent

One of the goals of OAuth is to protect a user's data and ensure it's shared with only parties that the user wants to share it with.If you think back the last time you clicked a Sign In with Twitter button, you might remember that you saw a screen like this asking if you are sure you want to share your information. This screen that interrupts the authorization flow is known as the consent screen because it's asking the user for permission. In this lesson, we'll look at how the screen is critical to the flow so that the authorization server knows it's doing its job and protecting the user in order to better understand why this step is useful. Let's first look at what happens if we don't have this screen in the flow. If you read through the OAuth spec, you'll see references to the password grant, also known as the resource owner password flow. The way that flow works is the application presents a password prompt in the app itself,collects the user's password and then sends it to the authorization server and gets back an access token. The request itself is so simple it's barely worth mentioning. It's just one POST request.  The token endpoint that contains the username and password along with the client and optionally the client secret.
Let's take a step back and think about this for a minute. The user hands over their password to the client and the client goes and takes it to the authorization server to get an access token. If you remember back in the first section of this course, we saw examples of third party apps asking you to enter your Gmail password. It's clearly a problem if a third party app were to use the password grant because the user is handing their password over to an app under another developer's control. This has always been a problem and the spec has always advised against allowing third party apps to use the password grant. What's more subtle, though, are the problems that even first party apps have when using the password grant. So let's think about this from the point of view of the authorization server. As the authorization server, your job is to protect the resources, ensuring only applications and users that are authorized get access.
If you get a password grant request, all you see is that the application is presenting the user's credentials. You don't actually have any way to know if the user themselves are actually trying to log in. You don't know if the user is using this app right now or if the app has stored the user's password from the last time they logged in. And that's because this request looks the same, whether or not the user is actually actively using the application. So even if you do trust the app not to store and replay the user's password, you also can't be sure that the user actually agrees to whatever access the app is requesting. It might be telling the user it's going to only read their photos, but because it has their password, it can actually request a token that could modify their photos too. The thing missing from this is actually confirming that the user is actually at the computer and has initiated and agrees to this request right now.
So this is really where the role of the authorization server solves this. By inserting the authorization server into the flow. The application actually first directs the user to the authorization server. The user types in their password there, approves the request after they see the consent screen, and then they get taken back to the app. This way, the user is only ever typing their password into the authorization server. And then the authorization server knows that the user is actually attempting to use that application. It prevents the application from being able to do anything without the user actually being in front of the keyboard. It also means the application can ask for certain kinds of access and the authorization server can show that request to the user. And that way the authorization server knows the user is actually agreeing to it. And that's this consent step here where the user is shown a prompt asking if they would like to share their data with the application. There's another huge problem with the password grant which is solved by using a redirect flow. In recent years, we've seen an explosion in the use of multifactor authentication, which is a huge step up for security. The problem with the password grant is there's really no room to add multifactor into the flow. The grant is just exchanging the password for an access token, and it wasn't designed to add multifactor into the flow.
If you did want to extend the password grant to support multifactor, you're going to have to just do it on your own and make it up and build it into each one of your applications from scratch. So instead, by redirecting the user to the authorization server, you can add a new multifactor method at any time by adding it to your authorization server. And then suddenly every application using that server will immediately support it without changing any of the code in the applications. This has a huge impact if you're responsible for deploying dozens or hundreds of apps, especially across different teams, since it means you no longer need to coordinate the efforts to change or add support for a new multifactor authentication methods, you could just turn them on with the authorization server whenever you want. The last thing I want to say about user consent is that typically the step of actually interrupting and asking the user for permission is skipped for first party confidential clients. The idea is that if you're logging into the web application of your own service where a user has an account, you don't really need to ask their permission to log in, since it's a first party scenario. And if it's a confidential client, then there's really no app impersonation risk either. So it's safe to skip the consent feature and redirect back immediately. That said, that redirect step is still key here as that's how you're able to get all the security benefits and better add multifactor authentication. But you can have the user automatically redirected back without a consent prompt if you wish. If you're on a mobile or single page app and if you are worried that someone might try to trick users into logging to a fake app, impersonating your own apps, then you might still want to turn on the consent feature for your own first party apps just so that you can make it harder for attackers to trick your users into authorizing a fake application. So in summary, using a redirect based method is a much safer and much more flexible alternative to the password grant and allows you to easily add multifactor authentication in the future and provides assurance that the user is really in front of the computer when logging into applications. 


## 2.8 Front Channel x Back Channel 

Before we dive in to how a secure OAuth flow works, I want to introduce the concept of thefront channel versus the back channel.These terms describe two different ways that data moves around between systems.The back channel is the "normal" way or the secure way.It's a client-to-server connection.There's a bunch of properties of a back channel connection that we often take forgranted. It's over HTTPS, so we know what server we're talking to because we can validatethat certificate. Once the connection is established, the data is then encrypted intransit so we know nobody can modify it.It also means that the response you get back you can trust, because you know where itcame from and you know it can't be tampered with.I like to think of this as hand delivering a package.You can walk up to somebody and hand them a package.You can see who they are. They can see who you are.You can see that nobody stole the package because you handed it to them directly.This is a very useful delivery mechanism and we should use it whenever we can.So the other way data moves around in OAuth is the front channel.Sending data in the front channel is literally using the address bar of the user'sbrowser to move data between two systems.So I like to think of the browser's address bar as using a package delivery serviceinstead of hand delivering a package.You package up a message, you hand it to a delivery company and then they deliver themessage for you. So there's no direct link between the sender of the package and therecipient, just like there's no direct link between the application and the OAuth server,when using the front channel.There are a few pretty significant problems with using the front channel, which make alot of sense if we think about the package delivery analogy.When you send a package, you generally trust the delivery service to get your package tothe destination because this is their job and you're paying them.But as the sender, you never really know if your package arrived.You might have tracking info on the package, but all that says is whether the deliverycompany claims the package was delivered.And even if the package does arrive, you can't really be sure that it wasn't opened up intransit or had the contents copied or stolen.So as much as you want to believe you trust the delivery service, or in the OAuth case,the browser, you never can be really sure.And there's a similar problem at the other end for the party receiving data in the frontchannel. When you receive a package, it might have a return address on it, but you can'treally be sure it's actually from the person at that address because it's too easy tofake a return address label.And that means you can't really be sure that the thing you received is legitimate either.So let's bring this back into the world of OAuth.So in OAuth, the end goal is for the application to get an access token from the OAuthserver. The most secure way to deliver that would be via the back channel.But as we talked about in the previous lesson, we also want to make sure that the userhas given their permission for an access token to be delivered to the application.So even though the password grant does use the back channel, we can't use it becausethere's no way to confirm the user actually consented to that request.And that's the reason we use the front channel at all.It's a way to insert the user into the negotiation between the client and theauthorization server. That way, the authorization server knows the user is actuallypresent and has given their permission.And of course, it's also how we can easily add multi factor authentication, since onlythe authorization server needs to worry about that.So with the front channel in mind, let's imagine building out a flow.The application needs to first tell the authorization server what it's trying to do.So that's the first step and that's the first package being sent.This request will include things like the application's identifier, what scope it'srequesting, things like that.And it's usually fine to send this in the front channel because nothing in this requestis particularly sensitive.So the application redirects the user to the authorization server with all of these bitsof information in the query string of a URL.Once the user logs in and approves the request, the authorization server is ready to sendan access token back to the application and send the user back to the application.If it were to send the access token back in the redirect, that would be like sending anaccess token in the mail.The authorization server wouldn't really have any guarantee that it was actuallydelivered back to the application.And the application also wouldn't really have any guarantee that the access token isreally from the authorization server.So this is clearly not a good option.But it turns out that this method is actually described in the core OAuth spec, but it'snot recommended any more because of the lack of security of this flow.And this is called the Implicit flow.So the Implicit flow works by using the front channel for both the request the app makes,as well as delivering the access token.And there is no backchannel in that flow.So if this is so bad, you might be wondering why it was included in OAuth at all.And the answer is that it used to be the case that browsers had no other option.As we'll see in a later section, the solution is to deliver the access token in the backchannel instead. But remember that the back channel is an HTTPS request from a client toa server. So if you're in a pure JavaScript app doing this flow, your JavaScript wouldneed the ability to make a POST request to the OAuth server.And it used to be the case that cross-origin requests weren't possible until browsersbuilt in support for Cross Origin Resource Sharing or CORS.Of course on the modern web, CORS is a part of everyday life, we don't even think aboutit anymore. So now that it's widely available, it's not a problem at all to use a moresecure flow that keeps access tokens out of the front channel.One more thing I want to clarify about the back channel, especially in the context ofJavaScript apps.The back channel does not mean a back end server.It means a client-to-server connection.So a JavaScript app can absolutely use the back channel.What that means is the back channel would be JavaScript making a request from JavaScriptcode like an AJAX or a Fetch request.Making a backchannel request from JavaScript does have the same security properties asmaking it backchannel request from a backend server.And that's because when you do a back channel request from the JavaScript code, you stillget certificate verification and an encrypted connection.And that's very different from sending data in the front channel, which is againliterally using the address bar to move data, where there's more opportunities for thingsto fail or be intercepted.So at this point, there's really no point in going over the details of the Implicit flowother than pointing out that the way it works is by delivering the access token in thefront channel. The latest guidance from the OAuth working group is phasing out theImplicit flow by including language in the latest Security BCP or Best Current Practice,saying not to use the Implicit flow.And a future update of the OAuth spec will leave it out entirely.But now that you understand the difference between the front channel and the back channeland understand the security implications of using each of those methods, you'll be betterable to evaluate the security properties of the different flows available.

Even though the request method is GET, this is a back-channel request since the JavaScript code handles the HTTP response directly.
Question 1:
Is the following JavaScript code making a front-channel or back-channel request?

  fetch("https://authorization-server.com/", {
    method: "GET",
    headers: {
      "Content-Type": "application/json"
    }
  })
  .then((response) => {
    return response.json();
  });

success alert
Good job!
Yes, this code redirects the user's browser to the URL shown. (AVOID)
Question 2:
Is the following JavaScript code making a front-channel or back-channel request?

window.location = 'https://authorization-server.com/authorize?client_id=example';

## 2.9 Application Identity

- Client ID => application uses that to identify itself throughout the OAuth flow.

The last concept I want to introduce before we dive into the details of an OAuth flow isthe idea of application identity.Applications -- or in OAuth terms, more specifically, clients -- they are their ownentity. You'll see this when you go to log in to an app and you're presented with theauthorization screen that says "this application would like to access your account."Which application? This application.And importantly, you might grant one application, different kinds of access than anotherapplication. Each application has its own identifier called a client ID, and theapplication uses that to identify itself throughout the OAuth flow.Now, this is closely related to the previous discussion about public versus confidentialclients. In that lesson, we learned about which kinds of apps can use a client secret,which is really just another name for the applications password.So without a password, or without a client secret, there isn't really ever the assurancethat the application using the client ID really is that application.So let's walk through a summary of doing the steps of an Authorization Code flow.And as we've seen, this is an improvement over the Implicit flow since the access tokenwill be delivered in the back channel.So this flow starts out with the application building up a URL to redirect the user'sbrowser to the authorization server.In this URL will be a bunch of parameters that describe the request the app is making,things like the scope of the request, the redirect URI telling the authorization serverwhere to send the user back to, also the client ID to identify which app is making thisrequest. The app builds this link and then redirects the user's browser there, whichtakes them to the authorization server.They log in at the authorization server, approve the request the app makes, and theauthorization server needs to redirect them back to the app.Now, remember, these redirect steps are front channel requests, which means ideally itshouldn't matter if something can intercept or modify the request.Everything should still work out fine and still be secure.So if the server returned the access token in that redirect step, that would be likesending the access token in the mail, opening it up to a bunch of different possibleattacks. So what if instead the server sent back something more like a one time usecoupon with a short expiration date?And that coupon could be exchanged for an access token, but only once and only within ashort time period. Using that coupon will require that the application go use the backchannel to redeem it. Ok, so we're going to call this coupon the authorization code andthe OAuth server can return that back in the redirect to the application.Now, keep in mind that it's possible that that authorization code might be stolen orcopied, which means the server can't really ever be surewhoever is redeeming that code is the real application.So we need some way to verify that.And that is with a client secret is for.Remember, the client secret is like the application's password.So if the application redeems this authorization code and proves it's the realapplication by authenticating with its password, then the authorization server knows it'sbeing redeemed by the real application and it hasn't been stolen.And this works because the application uses its client secret to prove its identity atthe authorization server when it makes that request for an access token.But what happens if the app can't prove its identity?And that would be the case for mobile apps or a single page apps which can't be deployedwith a client secret since these kinds of applications don't have a client secret.If they were to try to use the authorization code flow, the OAuth server wouldeffectively be letting any application that could steal the code get an access token.So we need some sort of solution to this, which it turns out is the PKCE extension, shortfor Proof Key for Code Exchange.We'll look at the details of that mechanism in the next couple of sections.But a high level summary of how it works is this: Before the app makes that first requestto start the flow, it actually makes up a unique secret for each request.And it uses that secret to start the flow, and again when it redeems the authorizationcode. And that lets the authorization server know that the thing redeeming the code isthe same thing that started the flow preventing authorization codes from being used ifthey are stolen. Now, that's great, but I chose my words carefully there because whatthis does not do is actually prove the app's identity or authenticate the app.All it does is make sure that the authorization code is used only by the same app thatstarted it. But it doesn't stop an attacker from impersonating an application without aclient secret. The OAuth flow is performed with information that's entirely public.So if someone really wanted to, they could start an OAuth flow with the public client ofsome other app. And if they were then able to steal the authorization code, they couldalso then get an access token.And that takes us to the last aspect of application identity, which is the redirect URI,the redirect URI is the location of the client where the authorization server is going tosend the user back to after they log in.And that's where the authorization code will be delivered in the front channel.For web apps and single page apps, it'll be a URL like https://example-app.com.For native apps and mobile apps and desktop,it might be a custom URL scheme instead, like myapp://redirect.And there's an important distinction between these two, closely related to the concept ofapplication identity.The URLs are considered to be globally unique.If I'm running a website example-app.com, that means nobody else can run a website atthat address. And that's because I've registered that domain and I own the DNS entry forit, but there isn't any global registration for custom URL schemes, which means even ifmy app claims that myapp:// scheme, you could publish an app claiming the same scheme.Now, different mobile platforms handle it differently if someone installs two apps thathandle the same scheme, but it means a custom URL scheme can't be used as any form ofapplication identity.Now, in recent years, mobile platforms have also started to allow native apps to takeover handling URL patterns for URLs.And in those cases, the app developer does have to prove they control the real domain.So Apple and Google won't let you publish an app into their stores using my domain.Only I can do that. So in that sense, the app's redirect URL -- if it's an HTTPS redirectURL -- is part of the app's identity.And in the case of mobile apps and single page apps without a client secret, this is theonly part of an app's identity that we can rely on.But even then, this isn't anywhere near as reliable as a client secret for proving theapp's identity. It's better than nothing, but it's still potentially problematic.And the unfortunate thing here is that there isn't really a proper solution for mobileapps and single page apps.This is the best we have today.And this might change in the future if mobile platforms add new APIs that could be used toauthenticate apps from their app stores.But today, this is the best we've got.Basically what it means is that if you don't have a client secret, if you're building apublic client, you need to be aware of this limitation when deciding policies aroundthings like token lifetimes and whether to skip the content screen.But the fact that this redirect URL is the only hint of confirming the app's identitywithout a client secret makes it that much more important that these redirect URLs areactually registered at the server.That ensures that the authorization server will only redirect to registered URLs for agiven client ID.We'll talk more about registration and how that works in the next section.All right. So that covers application identity.In the next few sections will take a closer look at how the OAuth flow works step by stepand will look at how PKCE works in more detail.